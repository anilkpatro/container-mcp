# cmcp/tools/matlab.py
# container-mcp Â© 2025 by Martin Bukowski is licensed under Apache 2.0

"""MATLAB tools for Container-MCP."""

from typing import Optional, Type, Dict, Any # Added Dict, Any
from pydantic import BaseModel, Field
from mcp.tools.tool import Tool
from cmcp.managers.matlab_manager import MatlabManager, MatlabResult, MatlabInput # Added MatlabInput
from cmcp.utils.logging import get_logger

logger = get_logger(__name__)

class MatlabCodeInterpreterArgs(BaseModel):
    """Arguments for MATLAB code interpreter tool."""
    code: str = Field(..., description="The MATLAB code to execute.")
    input_data: Optional[Dict[str, Any]] = Field(
        default=None,
        description="A dictionary of variables to be pre-loaded into the MATLAB workspace. E.g., {'my_var': [1, 2, 3], 'my_string': 'hello'}. These variables are saved to 'input.mat' and loaded at the start of the script."
    )
    timeout: Optional[int] = Field(None, description="Optional timeout in seconds for the execution.")

async def execute_matlab_code(
    matlab_manager: MatlabManager,
    code: str,
    input_data: Optional[Dict[str, Any]] = None,
    timeout: Optional[int] = None
) -> MatlabResult:
    """
    Wrapper function to execute MATLAB code using the MatlabManager,
    handling optional input data.
    This async wrapper is suitable for the Tool's func.
    """
    matlab_input_instance: Optional[MatlabInput] = None
    if input_data:
        matlab_input_instance = MatlabInput(variables=input_data)

    return await matlab_manager.execute(code=code, input_vars=matlab_input_instance, timeout=timeout)

def create_matlab_tools(mcp, matlab_manager: Optional[MatlabManager]):
    """
    Creates and registers MATLAB tools if the MatlabManager is available.

    Args:
        mcp: The MCP instance to register tools with.
        matlab_manager: Initialized instance of MatlabManager, or None if disabled/unavailable.
    """
    if not matlab_manager:
        logger.info("MatlabManager is not available or disabled. MATLAB tools will not be registered.")
        return

    matlab_tool = Tool(
        name="matlab_code_interpreter",
        description=(
            "Executes MATLAB code in a sandboxed environment. \n"
            "Capabilities:\n"
            "- Run MATLAB scripts and perform calculations.\n"
            "- Input Data: Pass Python variables to MATLAB using the `input_data` argument. This should be a dictionary where keys are variable names and values are the data (e.g., numbers, strings, lists/arrays). These variables are saved to an `input.mat` file and automatically loaded (using `load('input.mat');`) before your script runs.\n"
            "- Output Data: To return structured data (variables) from MATLAB back to Python, save the desired variables into a file named `output.mat` within your MATLAB script (e.g., `save('output.mat', 'varToReturn1', 'varToReturn2');`). These variables will be available in the `output_data` field of the result.\n"
            "- Figure Saving: Figures generated by commands like `plot`, `figure`, `surf`, etc., are automatically saved as image files (default format: PNG). Paths to these images are returned in the `images` list.\n"
            "- Standard I/O: Captures `stdout` (from `disp()`, script output) and `stderr`.\n"
            "Example for `input_data`: `{'my_array': [1, 2, 3], 'my_string': 'test'}`\n"
            "Example for returning data in MATLAB: `data_out = 42; save('output.mat', 'data_out');`"
        ),
        # The lambda now needs to unpack args from the model correctly
        func=lambda **kwargs: execute_matlab_code(matlab_manager, **kwargs),
        args_model=MatlabCodeInterpreterArgs,
        is_async=True
    )
    mcp.tools.add_tool(matlab_tool)
    logger.info("MATLAB code interpreter tool registered.")

__all__ = ["create_matlab_tools"]
