# cmcp/managers/matlab_manager.py
# container-mcp Â© 2025 by Martin Bukowski is licensed under Apache 2.0

"""MATLAB Manager for securely executing MATLAB code."""

import asyncio
import os
import tempfile
import shutil
import uuid
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field as PydanticField # Renamed Field to avoid conflict with dataclass field

# Attempt to import scipy.io, but don't fail at import time if not installed
# The manager should handle its absence gracefully at runtime if used.
try:
    import scipy.io
except ImportError:
    scipy = None # Will check for this in execute method

from cmcp.utils.logging import get_logger

logger = get_logger(__name__)

@dataclass
class MatlabResult:
    """
    Represents the result of a MATLAB code execution.

    Attributes:
        output: The standard output from the MATLAB code.
        error: The standard error from the MATLAB code.
        images: A list of paths to image files generated by the MATLAB code.
        output_data: Optional dictionary containing variables extracted from MATLAB's workspace.
    """
    output: str
    error: str
    images: List[str] = field(default_factory=list)
    output_data: Optional[Dict[str, Any]] = None


class MatlabInput(BaseModel):
    """
    Represents input data to be passed to a MATLAB execution.
    Variables in the dictionary will be saved to a .mat file and loaded by MATLAB.
    """
    variables: Dict[str, Any] = PydanticField( # Use PydanticField here
        default_factory=dict,
        description="Dictionary of variable names and their Python values to be passed to MATLAB."
    )


class MatlabManager:
    """Manager for secure MATLAB code execution."""

    def __init__(
        self,
        sandbox_dir: str,
        matlab_executable: str = "matlab",
        memory_limit: int = 1024,  # MB
        timeout_default: int = 60,  # seconds
        timeout_max: int = 300,     # seconds
        default_image_format: str = "png"
    ):
        """Initialize the MatlabManager.

        Args:
            sandbox_dir: Directory for sandbox operations.
            matlab_executable: Path to the MATLAB executable.
            memory_limit: Memory limit in MB.
            timeout_default: Default timeout in seconds.
            timeout_max: Maximum allowed timeout in seconds.
            default_image_format: Default format for saving figures (e.g., 'png', 'jpg').
        """
        self.sandbox_dir = sandbox_dir
        self.matlab_executable = matlab_executable
        self.memory_limit = memory_limit
        self.timeout_default = timeout_default
        self.timeout_max = timeout_max
        self.default_image_format = default_image_format

        # Ensure sandbox directory exists
        os.makedirs(self.sandbox_dir, exist_ok=True)
        logger.debug(f"MatlabManager initialized with sandbox at {self.sandbox_dir}")

    @classmethod
    def from_env(cls, app_config=None):
        """Create a MatlabManager from environment configuration.

        Args:
            app_config: Optional AppConfig object. If None, loads config from environment.

        Returns:
            Configured MatlabManager instance.
        """
        if app_config is None:
            from cmcp.config import load_config
            app_config = load_config()

        matlab_cfg = app_config.matlab_config

        if not matlab_cfg.enabled:
            logger.info("MATLAB Manager is disabled via configuration.")
            # Or raise an exception, or return a NullManager pattern object
            # For now, let's log and return None or raise error to make it explicit
            raise EnvironmentError("MatlabManager is disabled in the application configuration.")

        logger.debug("Creating MatlabManager from environment configuration.")
        return cls(
            sandbox_dir=matlab_cfg.sandbox_dir,
            matlab_executable=matlab_cfg.matlab_executable,
            memory_limit=matlab_cfg.memory_limit,
            timeout_default=matlab_cfg.timeout_default,
            timeout_max=matlab_cfg.timeout_max,
            default_image_format=matlab_cfg.default_image_format
        )

    async def execute(
        self,
        code: str,
        input_vars: Optional[MatlabInput] = None,
        timeout: Optional[int] = None
    ) -> MatlabResult:
        """
        Execute MATLAB code in a sandboxed environment.

        This method writes the provided MATLAB code to a temporary `.m` file and
        executes it using the configured MATLAB executable, sandboxed with Firejail
        if available. It automatically appends MATLAB commands to the user's code
        to save any generated figures (e.g., from `plot`, `figure`, `surf` commands)
        into the execution-specific sandbox directory.

        Args:
            code: The MATLAB code string to execute.
            input_vars: Optional MatlabInput object containing variables to be
                        loaded into the MATLAB workspace before execution.
            timeout: Optional timeout in seconds for the execution. If None,
                     `self.timeout_default` is used. The effective timeout is
                     capped by `self.timeout_max`.

        Returns:
            A MatlabResult object containing the standard output (`output`),
            standard error (`error`), a list of file paths (`images`) for any
            figures saved, and `output_data` (a dict of variables from `output.mat`).
        """
        if not scipy:
            logger.error("scipy.io is not available, cannot handle .mat files for input/output variables.")
            # Potentially raise an error or return a result indicating this failure
            # For now, proceed without .mat file handling if input_vars were given.
            if input_vars and input_vars.variables:
                 return MatlabResult(
                    output="",
                    error="scipy.io is required for input/output variable handling but is not installed.",
                    images=[],
                    output_data=None
                )
            # If no input_vars, we might still proceed for code execution without data I/O.

        if timeout is None:
            timeout = self.timeout_default
        timeout = min(timeout, self.timeout_max)

        # Create a unique directory within the sandbox for this execution
        execution_dir_name = f"matlab_exec_{uuid.uuid4()}"
        execution_dir = os.path.join(self.sandbox_dir, execution_dir_name)
        os.makedirs(execution_dir, exist_ok=True)

        matlab_script_content = ""
        input_mat_filename = "input.mat"
        output_mat_filename = "output.mat" # Expected filename for output variables

        # Handle input variables
        if input_vars and input_vars.variables:
            if not scipy:
                # This case should ideally be caught above, but double-check
                logger.error("Cannot save input.mat: scipy.io is not available.")
                # Decide if to error out or continue without input_vars
                # For this implementation, if input_vars were provided but scipy is missing, it's an error.
                return MatlabResult(output="", error="scipy.io is required to use input_vars but is not installed.", images=[])

            full_input_mat_path = os.path.join(execution_dir, input_mat_filename)
            try:
                scipy.io.savemat(full_input_mat_path, input_vars.variables)
                matlab_script_content += f"load('{input_mat_filename}');\n"
                logger.debug(f"Saved input variables to {full_input_mat_path}")
            except Exception as e:
                logger.error(f"Failed to save input.mat file: {e}", exc_info=True)
                # Decide: proceed without loading, or return error?
                # For now, return an error in MatlabResult.
                return MatlabResult(
                    output="",
                    error=f"Failed to serialize input variables to .mat file: {e}",
                    images=[],
                    output_data=None
                )

        matlab_script_content += code # Add user's code

        # Path for the temporary .m script
        # Use a fixed name for the script for simplicity inside the execution_dir.
        # The execution_dir itself is unique.
        temp_script_name = "run_script.m"
        temp_script_path = os.path.join(execution_dir, temp_script_name)

        generated_images = []

        # Prepare MATLAB code: add figure saving commands
        # This is a basic way to capture figures. More sophisticated methods might be needed.
        # We'll look for existing figure handles and save them.
        # Also, we'll append a command to save the current figure if one exists.
        # The user's code should save output variables to 'output.mat' if they want them back.
        # Example: save('output.mat', 'var1', 'var2');

        # Generate unique identifiers for figure filenames
        figure_uuid = uuid.uuid4().hex
        current_figure_uuid = uuid.uuid4().hex

        figure_saving_code = f"""
        % --- Auto-generated figure saving code ---
        disp('Attempting to save figures...');
        figHandles = findall(0, 'Type', 'figure');
        for i = 1:length(figHandles)
            fig = figHandles(i);
            if isvalid(fig)
                image_filename = fullfile('{execution_dir}', ['figure_handle_' num2str(fig.Number) '_{figure_uuid}.{self.default_image_format}']);
                try
                    saveas(fig, image_filename);
                    disp(['Saved figure: ' image_filename]);
                catch ME
                    disp(['Error saving figure ' num2str(fig.Number) ': ' ME.message]);
                end
            end
        end
        % Try to save current figure if any
        try
            currentFig = gcf;
            if ~isempty(currentFig.Name) || ~isempty(currentFig.Children) % Check if it's not an empty default figure
                image_filename_current = fullfile('{execution_dir}', ['figure_current_{current_figure_uuid}.{self.default_image_format}']);
                saveas(currentFig, image_filename_current);
                disp(['Saved current figure: ' image_filename_current]);
            end
        catch
            % No current figure or error saving
        end
        """

        full_code = f"""
        try
            cd('{execution_dir}'); % Change working directory
            {matlab_script_content} % This now includes potential load('input.mat') and user's code
        catch ME
            fprintf(2, 'Error during MATLAB script execution: %s\\n', ME.message);
            fprintf(2, 'Stacktrace:\\n');
            for k=1:length(ME.stack)
                fprintf(2, 'File: %s, Name: %s, Line: %d\\n', ME.stack(k).file, ME.stack(k).name, ME.stack(k).line);
            end
            exit(1); % Exit with error code
        end
        % Figure saving logic (run after user's code)
        {figure_saving_code}
        exit; % Ensure MATLAB exits after script execution
        """

        with open(temp_script_path, 'w') as f:
            f.write(full_code)

        # Construct MATLAB command
        # -batch: Executes the script non-interactively and exits MATLAB.
        # -nodesktop: Starts MATLAB without the desktop environment.
        # -nosplash: Starts MATLAB without the splash screen.
        # The script itself handles exiting.
        matlab_command_args = [
            "-batch",
            f"try, run('{temp_script_path}'); catch e, disp(getReport(e)); exit(1); end"
        ]

        sandbox_cmd_list = self._get_sandbox_command(execution_dir, matlab_command_args)
        logger.debug(f"Executing MATLAB code in {execution_dir} using command: {' '.join(sandbox_cmd_list)}")

        try:
            proc = await asyncio.create_subprocess_exec(
                *sandbox_cmd_list,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=execution_dir # Set CWD for the process as well
            )

            stdout_bytes, stderr_bytes = await asyncio.wait_for(proc.communicate(), timeout=timeout)

            stdout = stdout_bytes.decode(errors='ignore')
            stderr = stderr_bytes.decode(errors='ignore')

            if proc.returncode != 0:
                logger.warning(f"MATLAB execution exited with code {proc.returncode}. Stderr: {stderr}")
                # stderr might already contain MATLAB's error report from the script
                if not stderr: # if script didn't redirect its errors well
                    stderr += f"\nMATLAB process exited with code {proc.returncode}."

            # Scan execution_dir for generated images
            for item in os.listdir(execution_dir):
                if item.startswith("figure_") and item.endswith(f".{self.default_image_format}"):
                    generated_images.append(os.path.join(execution_dir, item))

            # Filter out image save messages from stdout if needed, or keep them for verbosity
            # For now, keeping them.

            # Handle output data
            output_data_cleaned = None
            if proc.returncode == 0 and scipy: # Only try to load if execution was ok and scipy is available
                full_output_mat_path = os.path.join(execution_dir, output_mat_filename)
                if os.path.exists(full_output_mat_path):
                    try:
                        output_data_raw = scipy.io.loadmat(full_output_mat_path)
                        output_data_cleaned = {
                            k: v for k, v in output_data_raw.items() if not k.startswith('__')
                        }
                        logger.debug(f"Loaded output variables from {full_output_mat_path}")
                    except Exception as e:
                        logger.error(f"Failed to load or parse output.mat file: {e}", exc_info=True)
                        # Append to stderr or handle as a separate error field?
                        stderr += f"\nWarning: Failed to load output data from {output_mat_filename}: {e}"
                else:
                    logger.debug(f"{output_mat_filename} not found in execution directory.")

            return MatlabResult(output=stdout, error=stderr, images=generated_images, output_data=output_data_cleaned)

        except asyncio.TimeoutError:
            logger.warning(f"MATLAB execution timed out after {timeout} seconds.")
            if proc and proc.returncode is None: # Ensure process is killed
                try:
                    proc.kill()
                    await proc.wait() # ensure it's reaped
                except ProcessLookupError:
                    pass # process already died
            return MatlabResult(output="", error=f"Execution timed out after {timeout} seconds.", images=[], output_data=None)
        except Exception as e:
            logger.error(f"Error during MATLAB execution: {e}", exc_info=True)
            return MatlabResult(output="", error=str(e), images=[], output_data=None)
        finally:
            # Option to keep sandbox dir for debugging or remove it
            # For now, let's keep it simple and not auto-remove, or make it configurable
            # shutil.rmtree(execution_dir, ignore_errors=True)
            # Script file should be cleaned up if execution_dir is not removed immediately
            if os.path.exists(temp_script_path):
                 pass # Keep it for now if execution_dir is kept
            logger.debug(f"MATLAB execution finished for script: {temp_script_path}")


    def _get_sandbox_command(self, execution_path: str, matlab_args: List[str]) -> List[str]:
        """
        Constructs the full command for running MATLAB within Firejail.
        Args:
            execution_path: The path within the sandbox where the script and output will reside.
            matlab_args: Arguments to pass to the MATLAB executable.
        Returns:
            A list of command arguments.
        """
        base_command = [self.matlab_executable, "-nodesktop", "-nosplash"] + matlab_args

        firejail_path = self._get_firejail_path()
        if not firejail_path:
            logger.warning("Firejail is not available. MATLAB will run without sandboxing. THIS IS INSECURE.")
            return base_command

        # Firejail command
        # --private=path: Mounts a temporary, private filesystem.
        # --net=none: Disables networking.
        # --quiet: Suppresses Firejail's own output.
        # --rlimit-as: Sets memory limit (approximate for MATLAB).
        # Note: MATLAB's actual memory usage can be complex. This limit is for the process tree.
        firejail_cmd = [
            firejail_path,  # Use the actual path to firejail
            "--quiet",
            f"--private={self.sandbox_dir}", # Mount the main sandbox dir as private
            f"--whitelist={execution_path}", # Whitelist the specific execution dir
             # Whitelist MATLAB executable and necessary paths. This can be complex.
            f"--whitelist={os.path.dirname(self.matlab_executable)}",
            # Add more whitelists as needed for MATLAB to function (e.g., license server, shared libs)
            # This is highly dependent on the MATLAB installation and environment.
            # Example: --whitelist=/usr/local/MATLAB/R2023b/
            "--net=none", # Disable networking for security
            "--caps.drop=all",
            "--nonewprivs",
            "--noroot",
            # "--seccomp", # Seccomp can be very restrictive; might need a custom profile for MATLAB
            # f"--rlimit-as={self.memory_limit * 1024 * 1024}", # Address space limit
        ]

        # If running inside a container, we might use different firejail settings
        # or rely on the container's own isolation.
        if self._is_container():
            logger.debug("Running inside a container, using container-optimized firejail settings (if applicable).")
            # Potentially adjust firejail_cmd for container environments
            # For now, using the same settings, but this could be a point of customization.

        return firejail_cmd + base_command

    def _is_container(self) -> bool:
        """Check if running in a container environment (common checks)."""
        return os.path.exists('/.dockerenv') or \
               os.getenv('DOTNET_RUNNING_IN_CONTAINER') == 'true' or \
               (os.path.exists('/proc/1/cgroup') and 'docker' in open('/proc/1/cgroup', 'rt').read())

    def _get_firejail_path(self) -> Optional[str]:
        """Get the path to Firejail if it's installed and available in PATH."""
        return shutil.which("firejail")
    
    def _is_firejail_available(self) -> bool:
        """Check if Firejail is installed and available in PATH."""
        return self._get_firejail_path() is not None

    async def close(self):
        """Clean up any persistent resources (if any)."""
        logger.debug("Closing MatlabManager.")
        # Currently, no specific cleanup is needed beyond what execute handles,
        # but this method is here for future extensions (e.g., persistent MATLAB sessions).
        pass

# Example usage (for testing purposes, if run directly)
async def main_test():
    logger.info("Starting MATLAB Manager test...")
    # This default path might not exist or be correct.
    # User should configure this based on their MATLAB installation.
    # On a typical Linux system, it might be /usr/local/MATLAB/R202Xa/bin/matlab
    # For testing without a real MATLAB, this will fail at subprocess execution.
    matlab_exe = shutil.which("matlab") or "matlab" # Try to find matlab in PATH

    if matlab_exe == "matlab" and not os.path.exists("/usr/local/MATLAB"): # Basic check if default is unlikely
        logger.warning("Default 'matlab' executable used. Ensure it's in PATH or provide full path.")
        logger.warning("If MATLAB is not installed, this test will fail.")

    manager = MatlabManager(
        sandbox_dir=os.path.join(tempfile.gettempdir(), "cmcp_matlab_test_sandbox"),
        matlab_executable=matlab_exe
    )

    test_code_simple = """
    disp('Hello from MATLAB!');
    a = 5;
    b = 10;
    c = a + b;
    disp(['Result: ' num2str(c)]);
    """

    test_code_with_plot = """
    disp('MATLAB script with plotting running...');
    x = 0:0.1:2*pi;
    y = sin(x);
    figure; % Create a new figure
    plot(x, y);
    title('Sine Wave');
    xlabel('X-axis');
    ylabel('Y-axis');
    % The appended saveas command in the manager should handle saving this.
    disp('Plotting complete.');
    """

    test_code_error = """
    disp('This script will generate an error.');
    nonExistentFunction(123);
    """

    logger.info("Testing simple execution...")
    result_simple = await manager.execute(test_code_simple, timeout=30)
    logger.info(f"Simple Output: {result_simple.output}")
    logger.info(f"Simple Error: {result_simple.error}")
    logger.info(f"Simple Images: {result_simple.images}")

    logger.info("\nTesting execution with plotting...")
    result_plot = await manager.execute(test_code_with_plot, timeout=90) # Plotting can be slow
    logger.info(f"Plot Output: {result_plot.output}")
    logger.info(f"Plot Error: {result_plot.error}")
    logger.info(f"Plot Images: {result_plot.images}")
    for img_path in result_plot.images:
        logger.info(f"Image available at: {img_path}")
        # Add logic here to verify if the image file actually exists, if needed for tests
        if not os.path.exists(img_path):
             logger.error(f"Image file not found: {img_path}")

    logger.info("\nTesting execution with an error...")
    result_error = await manager.execute(test_code_error, timeout=30)
    logger.info(f"Error Output: {result_error.output}")
    logger.info(f"Error Error: {result_error.error}") # Should contain MATLAB error
    logger.info(f"Error Images: {result_error.images}")

    await manager.close()

if __name__ == "__main__":
    # This setup is for being able to run the file directly for quick tests.
    # It's not meant for production use.
    logging_config = {
        "version": 1,
        "formatters": {
            "default": {
                "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
            },
        },
        "handlers": {
            "console": {
                "class": "logging.StreamHandler",
                "formatter": "default",
                "level": "DEBUG",
            },
        },
        "root": {
            "handlers": ["console"],
            "level": "DEBUG",
        },
        "disable_existing_loggers": False,
    }
    import logging.config
    logging.config.dictConfig(logging_config)

    # Check if Firejail is available and warn if not
    if not shutil.which("firejail"):
        logger.warning("Firejail is not installed or not in PATH. Sandboxing will not be effective.")
        logger.warning("Please install Firejail for secure execution: sudo apt-get install firejail")

    asyncio.run(main_test())
